#!/bin/sh --
# sx - start an xserver

# requires openssl xauth Xorg

# I'm willing to take advantage of errexit for this script as roughly 85% of
# the error checking would just be exiting on command failure.
set -o errexit

cleanup() {
    # Return to conventional flow control here as we need to continue
    # regardless of failure.
    set +o errexit

    if test "$1" -a "$(ps -o comm= "$1")" = Xorg; then
        kill "$1"

        # Send SIGKILL after 10 seconds if the xserver is taking too long to
        # terminate.
        interval=10
        until [ "$interval" -le 0 ]; do
            if ! kill -0 "$1"; then
                break
            fi
            sleep 1
            interval=$((interval - 1))
        done

        # Make sure that the PID still refers to an Xorg process
        if test "$interval" -le 0 -a "$(ps -o comm= "$1")" = Xorg; then
            kill -s KILL "$1"
        fi
    fi

    if ! stty "$stty"; then
        stty sane
    fi

    xauth remove :"$tty"
    exit
}

stty=$(stty -g)
tty=$(ps -o tty= $$)

case $tty in
    tty*) tty=${tty#tty}
esac

cfgdir=${XDG_CONFIG_HOME:-$HOME/.config}/sx
export XAUTHORITY=${XAUTHORITY:-$cfgdir/xauthority}

mkdir -p "$cfgdir" "${XAUTHORITY%/*}"
touch "$XAUTHORITY"

trap 'cleanup "$pid"' EXIT

xauth add :"$tty" MIT-MAGIC-COOKIE-1 "$(openssl rand -hex 16)"

# Xorg will check if SIGUSR1 was set to SIG_IGN in its environment and issue
# its own SIGUSR1 back to the parent process when it is ready to accept
# connections.  See Xserver(1).

# We take advantage of this feature to launch our client directly from the
# SIGUSR1 handler and avoid the need to poll for readiness.
trap 'DISPLAY=:$tty "${@:-$cfgdir/sxrc}"' USR1
(
    trap '' USR1
    exec /usr/lib/xorg-server/Xorg :"$tty" -keeptty vt"$tty" -noreset -auth "$XAUTHORITY"
) & pid=$!

wait
